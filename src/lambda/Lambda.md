##  함수형 프로그래밍 Functional Programming
함수를 정의하고 이 함수를 데이터 처리부로 보내 데이터를 처리하는 기법
데이터 처리부는 데이터만 가지고 있을 뿐 처리 방법이 정해져 있지 않아 외부에서 제공된 함수에 의존한다.
데이터 처리부는 제공된 함수의 입력값으로 데이터를 넣고 함수에 정의된 처리 내용을 실행한다. 동일한 데이터라도 함수A 를 제공해서 처리하는 결과와 함수  B를 제공해서 처리하는 결과는 다를 수 있다.
이것이 함수형 프로그래밍의 특징으로 데이터 처리의 다형성이라고도 볼 수 있다.

<br> 자바는 함수형 프로그래밍을 위해 Java 8  부터 람다식 Lambda Expressions을  지원한다.  람다식은 위 그림과 같이 데이터 처리부에 제공되는 함수 역할을 하는 매개변수를 가진 중괄호 블록이다. 데이터 처리부는 람다식을 받아 매개변수에 데이터를 대입하고 중괄호를 실행시켜 처리한다.
<br>

```markdown
람다식: (매개변수, ...) -> { 처리내용 }
```
자바는 람다식을 익명 구현 객체로 변환한다. 익명 구현 객체란 이름이 없는 인터페이스 구현 객체를 말하낟.
예를 들어 다음과 같이 Calculable 인터페이스가 있다고 가정해보자
```Java
public interface Calculable {
    // 추상 메소드
    void calculate(int x, int y);
}
```

Calculable 인터페이스의 익명 구현 객체는 다음과 같이 생성할 수 있다.

```Java
new Calculable() {
    @Override
        public void calculate (int x, int y){처리 내용}    
};
```

이것을 람다식으로 표현하면 다음과 같다. 추상 메소드인 calculate()는 두개의 매개변수를 가지므로 (x,y)로 표현되었고 화살표 뒤에 -> calculate() 의 실행 블록이 온다.
```Java
(x, y) -> {처리 내용};
```
람디식은 인터페이스의 익명구현객체 이므로 인터페이스 타입의 매개변수에 대입될 수 있다. 예를 들어 다음과 같이 Calculable 매개변수를 가지고 있는 action() 메소드가 있다고 가정해보자
```Java
public void action(Calculable calculable) {
    int x  = 10;
    int y = 4;
    calculable.calculate(x, y); // 데이터를 제공하고 추상 메소드를 호출
}
```
action() 매소드를 호출할 때 매개값으로 다음과 같이 람다식을 제공할 수 있다. action()메소드에서 calculable.calculate(x,y)를 실행하면 람다식의 중괄호 블록이 실행되면서 데이터 가 처리된다.
여기서 action()메소드는 제공된 람다식을 이용해서 내부 데이터를 처리하는 처리부 역할을 한다.
```Java
action( (x,y) -> {
    int result = x+y;
    System.out.println(result);
});
```
x와 y의 값이 정해져도 calculator()메소드로 데이터를 제공하고 추상메소드를 호출하고 람다식을 제공하는 메소드에서 결과값을 다루는 내부 데이터 처리부 역할을 통해 서로 다른 결과를 내보낻다ㅏ.
인터페이스 익명 구현 객체를 람다식으로 표현하려면 인터페이스가 가진 단 하나의 추상 메소드만 가져야한다. 따라서 다음과 같이 두개 이상의 추상메소드를 가진 RemoteControl 인터페이스는 람다식으로 표현할 수 없다.

```Java
public interface RemoteControl {
    void turnOn();
    void turnOff();
}
```
인터페이스가 단 하나의 추상 메소드를 가질 때 이를 함수형 인터페이스라고 한다. 다음 인터페이스들은 함수형 인터페이스들이다.
 인터페이스
```Java
public interface Runnable{
    void run();
}
```
람다식
```markdown
() -> { ...}
```

```Java
@FunctionalInterface
public interface Calculable{
    void calculate(int x, int y);
}
```
림다식
```markdown
(x, y) -> { ... }
```

인터페이스가 함수형 인터페이스임을 보장하기 위해서는 @FunctionalInterface 어노테이션을 붙이면 된다.
@FunctionalInterface를 붙이는 것은 선택사항이지만, 컴파일과정에서 추상 메소드가 하나인지 검사하기 때문에 정확한 함수형 인터페이스를 작성할 수 있게 도와주는 역할을 한다.
Calculable 인터페이스를 작성해본다.

## 매개변수가 없는 람다식
함수형 인터페이스의 추상 메소드에 매개변수가 없을 경우 람다식은 다음과  같이 작성할 수 있다. 
실행문이 두개 이상일 경우에는 중괄호를 생략할 수 없고 하나일 경우에만 생략할 수 있다.
```markdown
() -> {
    실행문;
    실행문;
}
```
```markdown
() ->  실행문
```

Workable 인터ㅓ페이스에 매개변수가 없는 work() 추상 매소드를 작성해본다.

### 매개변수가 있는 람다식
함수형 인터페이스의 추상 메소드에 매개변수가 있을 경우 람다식은 다음과 같이 작성할 수 있다. 매개변수를 선언할 때 타입은 생략할 수 있고, 구체적인 타입 대신에  var를 사용할 수도 있다.
하지만 타입을 생략하고 작성하는 것이 일반적이다.

```markdown
(타입, 매개변수, ...) -> {
    실행문;
    실행문;
}


(타입, 매개변수, ...) -> 실행문
```
```markdown

(var 매개변수, ...) -> {
    실행문;
    실행문;
}


(var 매개변수, ...) -> 실행문

```

```markdown
(매개변수, ...) -> {
    실행문;
    실행문;
}

(매개변수, ...) -> 실행문
```

매개변수가 하나일 경우에는 괄호를 생략할 수도 있다. 이때는 타입 또는 var를 붙일 수 없다.
```markdown
매개변수 -> {
    실행문;
    실행문;
}


매개변수 -> 실행문
```
Workable02 인터페이스에 매개변수가 두개 있는 work() 추상 메소드를 작성해본다.
