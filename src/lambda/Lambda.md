##  함수형 프로그래밍 Functional Programming
함수를 정의하고 이 함수를 데이터 처리부로 보내 데이터를 처리하는 기법
데이터 처리부는 데이터만 가지고 있을 뿐 처리 방법이 정해져 있지 않아 외부에서 제공된 함수에 의존한다.
데이터 처리부는 제공된 함수의 입력값으로 데이터를 넣고 함수에 정의된 처리 내용을 실행한다. 동일한 데이터라도 함수A 를 제공해서 처리하는 결과와 함수  B를 제공해서 처리하는 결과는 다를 수 있다.
이것이 함수형 프로그래밍의 특징으로 데이터 처리의 다형성이라고도 볼 수 있다.

<br> 자바는 함수형 프로그래밍을 위해 Java 8  부터 람다식 Lambda Expressions을  지원한다.  람다식은 위 그림과 같이 데이터 처리부에 제공되는 함수 역할을 하는 매개변수를 가진 중괄호 블록이다. 데이터 처리부는 람다식을 받아 매개변수에 데이터를 대입하고 중괄호를 실행시켜 처리한다.
<br>

```markdown
람다식: (매개변수, ...) -> { 처리내용 }
```
자바는 람다식을 익명 구현 객체로 변환한다. 익명 구현 객체란 이름이 없는 인터페이스 구현 객체를 말하낟.
예를 들어 다음과 같이 Calculable 인터페이스가 있다고 가정해보자
```Java
public interface Calculable {
    // 추상 메소드
    void calculate(int x, int y);
}
```

Calculable 인터페이스의 익명 구현 객체는 다음과 같이 생성할 수 있다.

```Java
new Calculable() {
    @Override
        public void calculate (int x, int y){처리 내용}    
};
```

이것을 람다식으로 표현하면 다음과 같다. 추상 메소드인 calculate()는 두개의 매개변수를 가지므로 (x,y)로 표현되었고 화살표 뒤에 -> calculate() 의 실행 블록이 온다.
```Java
(x, y) -> {처리 내용};
```
람디식은 인터페이스의 익명구현객체 이므로 인터페이스 타입의 매개변수에 대입될 수 있다. 예를 들어 다음과 같이 Calculable 매개변수를 가지고 있는 action() 메소드가 있다고 가정해보자
```Java
public void action(Calculable calculable) {
    int x  = 10;
    int y = 4;
    calculable.calculate(x, y); // 데이터를 제공하고 추상 메소드를 호출
}
```
action() 매소드를 호출할 때 매개값으로 다음과 같이 람다식을 제공할 수 있다. action()메소드에서 calculable.calculate(x,y)를 실행하면 람다식의 중괄호 블록이 실행되면서 데이터 가 처리된다.
여기서 action()메소드는 제공된 람다식을 이용해서 내부 데이터를 처리하는 처리부 역할을 한다.
```Java
action( (x,y) -> {
    int result = x+y;
    System.out.println(result);
});
```
x와 y의 값이 정해져도 calculator()메소드로 데이터를 제공하고 추상메소드를 호출하고 람다식을 제공하는 메소드에서 결과값을 다루는 내부 데이터 처리부 역할을 통해 서로 다른 결과를 내보낻다ㅏ.
인터페이스 익명 구현 객체를 람다식으로 표현하려면 인터페이스가 가진 단 하나의 추상 메소드만 가져야한다. 따라서 다음과 같이 두개 이상의 추상메소드를 가진 RemoteControl 인터페이스는 람다식으로 표현할 수 없다.

```Java
public interface RemoteControl {
    void turnOn();
    void turnOff();
}
```
인터페이스가 단 하나의 추상 메소드를 가질 때 이를 함수형 인터페이스라고 한다. 다음 인터페이스들은 함수형 인터페이스들이다.
 인터페이스
```Java
public interface Runnable{
    void run();
}
```
람다식
```markdown
() -> { ...}
```

```Java
@FunctionalInterface
public interface Calculable{
    void calculate(int x, int y);
}
```
림다식
```markdown
(x, y) -> { ... }
```

인터페이스가 함수형 인터페이스임을 보장하기 위해서는 @FunctionalInterface 어노테이션을 붙이면 된다.
@FunctionalInterface를 붙이는 것은 선택사항이지만, 컴파일과정에서 추상 메소드가 하나인지 검사하기 때문에 정확한 함수형 인터페이스를 작성할 수 있게 도와주는 역할을 한다.
Calculable 인터페이스를 작성해본다.

## 매개변수가 없는 람다식
함수형 인터페이스의 추상 메소드에 매개변수가 없을 경우 람다식은 다음과  같이 작성할 수 있다. 
실행문이 두개 이상일 경우에는 중괄호를 생략할 수 없고 하나일 경우에만 생략할 수 있다.
```markdown
() -> {
    실행문;
    실행문;
}
```
```markdown
() ->  실행문
```

Workable 인터ㅓ페이스에 매개변수가 없는 work() 추상 매소드를 작성해본다.

### 매개변수가 있는 람다식
함수형 인터페이스의 추상 메소드에 매개변수가 있을 경우 람다식은 다음과 같이 작성할 수 있다. 매개변수를 선언할 때 타입은 생략할 수 있고, 구체적인 타입 대신에  var를 사용할 수도 있다.
하지만 타입을 생략하고 작성하는 것이 일반적이다.

```markdown
(타입, 매개변수, ...) -> {
    실행문;
    실행문;
}


(타입, 매개변수, ...) -> 실행문
```
```markdown

(var 매개변수, ...) -> {
    실행문;
    실행문;
}


(var 매개변수, ...) -> 실행문

```

```markdown
(매개변수, ...) -> {
    실행문;
    실행문;
}

(매개변수, ...) -> 실행문
```

매개변수가 하나일 경우에는 괄호를 생략할 수도 있다. 이때는 타입 또는 var를 붙일 수 없다.
```markdown
매개변수 -> {
    실행문;
    실행문;
}


매개변수 -> 실행문
```
Workable02 인터페이스에 매개변수가 두개 있는 work() 추상 메소드를 작성해본다.



### 리턴값이 있는 람다식
함수형 인터페이스의 추상 메소드에 리턴값이 있을 경우 작성하는 경우다.
return문 하나만 있을 경우에는 중괄호와 함께  return 키워드를 생략할 수 있다. 리턴값은 연산식 똔느 리턴값 있는 메소드 호출로 대체할 수 있다.
```markdown
( 매개변수 , ...) -> {
    실행문;
    retrun 값;
}

```

```markdown
 (매개변수, ...) -> return 값;
 (매개변수, ...) -> 깂
```
Calcuable 인터페이스에 리턴값이 있는 calc() 추상 메소드를 작성한다.

## 메소드 참조
메소드 참조는 말그대로 메소드를 참조해서 매개변수의 정보 및 리턴 타입을 알아내 람다식에서 불필요한 매개변수를 제거하는 것을 목적으로 한다.
예를 들어 두개의 값을 받아 큰 수를 리턴하는  Math 클래스의  max()  정적 메소드를 호출하는 람다식은 다음과 같다.
```markdown
(left, right) -> Math.max(left, right);
```

람다식은 단순히 두개의 값을 Math.max()메소드의 매개값으로 전달하는 역할만 하기 떼문에 불편해 보인다. 이경우에는 다음과 같이 메소드 참조를 이용하면 매우 깔끔하게 처리할 수 있다.
```markdown
Math :: max;
```
### 정적 메소드와 인스턴스 메소드 참조
정적 메소드를 참조할 경우에는 클래스 이름 뒤에 :: 기호를 붙이고 정적 메소드 이름을 기술한다.
```markdown
클래스 :: 메소드
```

인스턴스 메소드일 경우 먼저 객체를 생성한 다음 참조 변수 뒤에 :: 기호를 붙이고 인스턴스 메소드 이름을 참조한다.
```markdown
 참조변수 :: 메소드
```
### 매개변수의 메소드 참조
a 매개변수의 메소드를 호출해서 b  매개변수를 매개값으로 사용하는 경우도 있다.
```markdown
(a,b) -> {a.instanceMethod(b); }
```
이겻을 메소드 참조로 표현하면 다음과  같다.
 a 클래스 이름 뒤에 :: 기호를 붙이고 메소드 이름을 기술한다.
```markdown

클래스 :: instanceMethod
```
Comparable - Person - MethodReferenceExample

## 생성자 참조
객체를 생성한다는 것을 의미한다.
람다식이 단순히 객체를 생성하고 리턴하도록 구성된다면 람다식을 생성잦 참조로 대치할 수 있다.
다음코드를 보면 람다식은 단순히 객체를 생성한 후 리턴만 한다.
```markdown
(a,b) -> {return new 클래스(a,b); }
```
이것을 생성자 참조로 표현하면 다음과 같다
```markdown
클래스 :: new 
```
 생성자가 오버로딩되어 여러개가 있을 경우, 컴파일러가 함수형 인터페이스의 추상메소드와 동일한 매개변수 타입과 개수를 가지고 있는 생성자를 찾아 실행한다.
만약 해당 생성자가 존재하지 않으면 컴파일 오류가 발생한다.

Creatable01 - Creatable02 - Member - Person06 - ConstructorRefenceExample


